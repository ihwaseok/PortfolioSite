<!-- --- --><!-- title: 개요 --><!-- updated: 2022-12-15 03:06:57Z --><!-- created: 2022-12-08 05:59:31Z --><!-- latitude: 37.26357270 --><!-- longitude: 127.02860090 --><!-- altitude: 0.0000 --><!-- tags: --><!--   - java --><!-- --- -->### Spring- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크- 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스를 제공하는 자바 프레임워크<br>### 경량급-	가볍고 단순한 환경에서도 복잡한 <abbr title="기업환경 시스템 구축을 위한 서버 애플리케이션">EJB</abbr>와 고가의 <abbr title="동적 컨텐츠(DB조회) 제공을 위한 애플리케이션 서버">WAS</abbr>를 갖춰야만 가능했던 엔터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다-	불필요하게 등장하던 프레임워크와 서버환경에 의존적인 부분을 제거해주기 때문에 스프링 기반의 코드는 상대적으로 작고 단순하다-	만들어진 코드가 지원하는 기술수준은 비슷하더라도 그것을 훨씬 빠르고 간편하게 작성하게 해 줌으로써 생산성과 품질 면에서 유리하다<br>### 애플리케이션 프레임워크- 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크 (특정 계층이나 업무분야에 국한되지 않는다)-	애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크-	애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 해서    각 분야의 특성에 맞는 필요를 채워주고 있기 때문에, 애플리케이션을 빠르고 효과적으로 개발할 수가 있다<br>![d90c89a75065636fa9b86b84bbd2eaac.png](/joplinRes/_resources/d90c89a75065636fa9b86b84bbd2eaac.png)<blockquote>JDBC = Java Database Connectivity<br>ORM = Object Relational Mapping<br>OXM = Object-XML Mapping<br>JMS = Java Message Service<br>SpEL = Spring Expression Language</blockquote>![01a45bda3755eee3008fc4f95d00fabe.png](/joplinRes/_resources/01a45bda3755eee3008fc4f95d00fabe.png)<blockquote>1. 웹 애플리케이션이 실행되면 WAS(톰캣)에 의해 web.xml이 로딩된다<br>2. web.xml에 등록되어 있는 Context Loader Listener(Java Class)가 생성된다<br>&nbsp; &nbsp; CLL클래스는 Servlet Context Listener인터페이스를 구현하고 있으며, Application Context를 생성하는 역할을 한다<br>3. 생성된 CLL은 root-context.xml을 로딩한다<br>4. root-context.xml에 등록되어 있는 Spring Container가 구동된다<br>&nbsp; &nbsp; 이 때 개발자가 작성한 비즈니스 로직에 대한 부분과 <abbr title="데이터베이스의 Data에 접근하기 위한 객체">DAO</abbr>, <abbr title="값 오브젝트, DTO에서 Setter가 빠진 읽기 전용 객체">VO</abbr> 객체들이 생성된다<br>5. 클라이언트로 부터 웹 애플리케이션 요청이 온다<br>	6. Dispatcher Servlet (<abbr title="클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송하는 프로그램">Servlet</abbr>)이 생성된다<br>&nbsp; &nbsp; DS는 Front Controller의 역할을 수행한다<br>&nbsp; &nbsp; 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 Page Controller에게 전달하고 응답을 받아 해당 응답을 어떻게 할지 결정만 한다<br>&nbsp; &nbsp; 실질적인 작업은 Page Controller에서 이루어지기 때문이다 (이러한 클래스들을 Handler Mapping, View Resolver 클래스라 한다)<br>7. DS는 servlet-context.xml을 로딩한다<br>8. 두번째 Spring Container가 구동되며 응답에 맞는 Page Controller들이 동작한다<br>&nbsp; &nbsp; 이 때 첫번째 Spring Container가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다</blockquote>