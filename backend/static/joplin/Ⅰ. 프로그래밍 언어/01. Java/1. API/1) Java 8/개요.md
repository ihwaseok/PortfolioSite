<!-- --- --><!-- title: 개요 --><!-- updated: 2023-01-06 07:36:27Z --><!-- created: 2022-12-16 09:17:44Z --><!-- latitude: 37.26357270 --><!-- longitude: 127.02860090 --><!-- altitude: 0.0000 --><!-- --- --><b style="font-size:30px">[Java 8](https://devdocs.io/openjdk~8/)</b> &nbsp;&nbsp;(이전버전 포함)---## 람다 표현식- <abbr title="메소드를 하나만 가지는 인터페이스">함수형 인터페이스</abbr>를 구현한 객체 → 매개 변수만을 사용하도록 만든 함수로 외부 자료에 부수적인 영향이 발생하지 않도록 함 → 외부에 영향을 미치지 않으므로 병렬 처리등에 가능  → 안정적인 확장성 있는 프로그래밍 방식- 클래스를 호출하지 않고 함수의 호출만으로 기능을 수행- 익명객체를 이용하여 수행됨- 함수형 인터페이스 생성시 @FunctionalInterface 어노테이션을 사용- `(파라미터 목록) -> { 람다식 바디 }`- 파라미터가 1개면 () 생략 가능하고 메소드 참조 ::를 이용하여 표현 가능```javaRunnable r = new Runnable() {	public void run() {		System.out.println("Howdy, world!");	}};```<font size="10">&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; ↓</font>```javaRunnable r = () -> System.out.println("Howdy, world!");``````java// 람다를 이용한 컬렉션 순회List<String> list = new ArrayList();list.add("Element1");list.add("Element2");list.add("Element3");list.forEach(x -> System.out.println(x)) // forEach(System.out::println) 과 동일```<br>## 스트림- 컬렉션, 배열 등에 저장되어있는 요소들을 하나씩 참조하며 반복적인 처리를 가능하게 하는 기능- 원본 데이터 자체를 변경하지 않는다-  한 번 사용하면 닫혀서 재사용 불가능 → 일회용-  작업을 내부 반복으로 처리   → 반복문이 노출되지 않음- Stream 생성 = 컬렉션, 배열, 파일, 람다식 등의 데이터 소스에서 생성- 중개연산 = Stream을 전달받아 Stream을 반환하는 연산 (필터링, 변환, 제한, 정렬...)- 최종연산 = 중개연산으로 만들어진 Stream의 각 요소들을 소모하여 최종결과 표시 (수집, 출력, 검색, 검사, 통계, 연산...)- `배열.Stream생성().중개연산().최종연산()````java// iterate를 이용하여 Stream생성Stream<Integer> iteratedStream = Stream.iterate(30, n -> n + 2).limit(5); // [30, 32, 34, 36, 38]// Stream내의 String을 대문자로 변환Stream<String> stream = names.stream().map(String::toUpperCase); // map(x -> x.toUpperCase())와 동일// Stream의 개수 반환long count = IntStream.of(1, 3, 5, 7, 9).count();// JPA로 가져온 Entity를 Dto로 변환public List<TestDto> findTestList(TestDto testDto) {	return testRepository.findAll().stream()			.map(testEntity -> new TestDto(testEntity))			.collect(Collectors.toList());}```<br>## 비교 및 조작이 용이한 날짜, 시간 API- LocalDate = 날짜- LocalTime = 시간- LocalDateTime = 날짜와 시간- ZonedDateTime = 특정 타임존의 날짜와 시간- Instant = 특정 시점의 시간표기 클래스 (두 시점간의 시간적 우선순위)```javaDateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM");LocalDate startDate = LocalDate.parse("2022-12-23");String M0 = startDate.format(formatter);		// 12String M1 = startDate.plusMonths(1).format(formatter);	// 01String M2 = startDate.plusMonths(2).format(formatter);	// 02LocalDate today = LocalDate.now();	// 2022-12-23today = today.minusMonths(8);		// 2022-04-23LocalDate startDT = LocalDate.of(today.getYear(), today.getMonth(), 1);	// 2022-04-01today = today.plusMonths(12);		// 2023-04-23LocalDate endDT = LocalDate.of(today.getYear(), today.getMonth(), 1);	// 2023-04-01endDT = endDT.minusDays(1);		// 2023-03-31```<br>## 인터페이스 사용가능 키워드 추가- 인터페이스에서 메소드에 default 키워드를 추가하면 구현부를 선언 가능 → 인터페이스를 구현하는 클래스에서 메소드가 이름만 있고 구현부가 비어있는 경우를 줄일 수 있음 (구현 필요 없음) → 인터페이스는 여러개를 구현 가능한 점을 이용해 다중 상속 가능- static 메소드 선언 가능 → 호출은 `Interface이름.메소드` 으로 가능```javapublic interface Vehicle {    public default void doSomething() {        System.out.println("doSomething(Vehicle)");    }}public static class Car implements Vehicle {	public static void main(String args[]) {		Car car = new Car();		car.doSomething(); // doSomething(Vehicle) 출력	}}```<br>## 옵셔널- null이 될 수도 있는 객체를 감싸고 있는 일종의 래퍼 클래스- null 처리를 쉽게 가능```javapublic String getCityOfMemberFromOrder(Order order) {	if (order != null) {		Member member = order.getMember();		if (member != null) {			Address address = member.getAddress();			if (address != null) {				String city = address.getCity();				if (city != null) {					return city;				}			}		}	}	return "Seoul"; // default}```<font size="10">&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; ↓</font>```javapublic String getCityOfMemberFromOrder(Order order) {	return Optional.ofNullable(order)			.map(Order::getMember)				.map(Member::getAddress)				.map(Address::getCity)					.orElse("Seoul");}```<br>## 이전 버전|명칭|설명||--|--||리플렉션|구체적인 클래스 타입을 알지 못해도 그 클래스에 접근할 수 있도록 해주는 API||익명 클래스|일시적으로 한번만 사용되고 버려지는 객체 (~$.class)||정규 표현식|특정한 규칙을 가진 문자열의 집합을 표시하는데 사용되는 언어||XML API|XML파일 처리 API||제네릭|클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법||어노테이션|컴파일과 실행 과정에서 코드를 어떻게 처리해야하는지 알려주는 메타데이터||박싱/언박싱|원시타입을 참조타입(Wrapper)으로 바꾸는 것 / 참조타입을 원시타입으로 바꾸는 것||Enumeration|순환 인터페이스 (삭제 기능없는 Iterator)||가변 파라미터|메소드에서 동적으로 매개변수를 받는 것||static import|메소드나 변수를 패키지, 클래스명 없이 접근 가능||Concurrency API|동기화가 필요한 상황에서 쓸 수 있는 유틸리티 클래스 제공||Java Compiler API|javac 컴파일러 도구에 액세스 할 수 있는 API||Try-With-Resources|명시적으로 close()쓰지 않아도 자동으로 자원을 해제||숫자에 _ 지원|가독성을 위해 숫자에 _ 붙일 수 있도록 지원||File NIO|File 새로운 입출력(New Input/Output) 지원|![788f9a4f22728b9c81368534b2bf083b.png](/joplinRes/_resources/788f9a4f22728b9c81368534b2bf083b.png)