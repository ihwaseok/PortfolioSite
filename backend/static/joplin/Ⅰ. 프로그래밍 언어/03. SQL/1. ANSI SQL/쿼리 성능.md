<!-- --- --><!-- title: 쿼리 성능 --><!-- updated: 2023-01-20 07:35:09Z --><!-- created: 2023-01-20 07:35:03Z --><!-- latitude: 37.44491680 --><!-- longitude: 127.13886840 --><!-- altitude: 0.0000 --><!-- --- -->## 인덱스 컬럼으로 테이블 데이터 줄이기- `WHERE`에서 인덱스 컬럼을 사용하면 인덱스 스캔이 적용되어 속도가 향상된다<br>## 필요한 컬럼만 가져오기- \* 를 사용하여 모든 컬럼을 가져오면 불필요한 자원이 소모된다<br>## 테이블 참조와 데이터 개수는 가능한 적게 유지- 조인 사용을 최소화 하여 테이블 접근을 적게 해야한다- `WHERE`조건을 잘 사용하여 테이블에서 가능한 적은 데이터를 가져와야 한다<br>## LIKE 사용시 앞에 % 붙이지 않기- 앞에 \%를 붙이면 검색 효율이 낮아진다  → 인덱스 스캔이 적용되지 않는다  → 포함된 모든 단어를 검색하게 된다## IN 보다 EXISTS 사용- 실행순서 상 `EXISTS`가 유리하다	- `IN` = `IN 쿼리` → `메인 쿼리`	- `EXISTS` = `메인 쿼리` → `EXISTS 쿼리`- `IN`은 조건을 모든 `IN 결과`에 비교 대입하고 종료된다- `EXISTS`는 조건을 만족하는 `EXISTS 결과`가 하나라도 발견되면 종료된다<br>## UNION 보다 UNION ALL 사용- 중복을 제거하는 과정에서 모든 행에 접근하기 때문에 속도가 느리다- 자동으로 정렬이 되기 때문에 속도가 느리다<br>## 삭제할 데이터가 더 많은 경우 DROP 사용- `DELETE`보다 `DROP`이 더 빠르게 실행된다- 단, 복구가 불가능하기 때문에 사용시 주의 필요<br>## 테이블 JOIN 시 인덱스 컬럼 사용- 조인 사용시 인덱스 컬럼을 사용하면 인덱스 스캔으로 적용된다<br>## 가능한 INNER JOIN 사용- `OUTTER 조인`보다 `INNER JOIN`이 성능상 유리하다<br>## HAVING 보다 WHERE 사용으로 데이터 개수 줄이기- 실행순서 상 `WHERE`가 빠르다- `HAVING`은 집계함수로 밖에 조건을 줄 수 없다<br>## NOT 사용 최소화- 부정형 조건은 인덱스 스캔이 적용되지 않는다- 부정형은 긍정형 보다 옵티마이저에서 처리량이 많다<br>## IS NULL 사용 최소화- `NULL`조건은 인덱스 스캔이 적용되지 않는다<br>## 테이블 중복 접근 최소화- 하나의 쿼리에서 같은 테이블은 가능한 한번의 접근으로 필요한 데이터를 찾아야 한다<br>## SELECT 에서 테이블 참조 최소화- `SELECT`에서 사용되는 서브 쿼리는 메인쿼리의 행 개수만큼 반복된다<br>## 정렬 사용 최소화- 정렬은 모든 데이터에 접근해야 하기 때문에 시간이 오래 걸린다- 필요한 경우 가능하면 인덱스 컬럼을 사용하여 정렬<br>## 조건절에 함수 사용 최소화- 함수를 사용하여 컬럼을 변형시키면 인덱스 스캔이 적용되지 않는다<br>## 임시테이블 사용 최소화- 임시테이블 생성 시 메모리를 점유하게 되기 때문에 가능한 적게 사용해야 한다<br>## 입출력 요청 최소화- 입출력 요청은 대부분의 쿼리보다 많은 시간이 걸리기 때문에 한번의 쿼리로 필요한 데이터를 가져와야 한다<br>## 통계정보 최신화- 쿼리가 갑자기 느려지는 경우 테이블의 통계정보를 최신화 해야 한다