				<!DOCTYPE html>				<html>					<head>						<meta charset="UTF-8">						<meta name="viewport" content="width=device-width, initial-scale=1" />						<link rel="stylesheet" src="/joplin/pluginAssets/katex/katex.css"><script type="application/javascript" src="/joplin/pluginAssets/mermaid/mermaid.min.js"></script><script type="application/javascript" src="/joplin/pluginAssets/mermaid/mermaid_render.js"></script><link rel="stylesheet" src="/joplin/pluginAssets/highlight.js/atom-one-light.css">						<title>내장 함수</title>					</head>					<body>						<div class="exported-note"><div class="exported-note-title">내장 함수</div><style>		/* https://necolas.github.io/normalize.css/ */		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}		body {			font-size: 15px;			color: #32373F;			word-wrap: break-word;			line-height: 1.6em;			background-color: #ffffff;			font-family: 'Avenir', 'Arial', sans-serif;			padding-bottom: 0px;			padding-top: 0px;		}		kbd {			border: 1px solid rgb(220, 220, 220);			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);			padding: 2px 4px;			border-radius: 3px;			background-color: rgb(243, 243, 243);		}		::-webkit-scrollbar {			width: 7px;			height: 7px;		}		::-webkit-scrollbar-corner {			background: none;		}		::-webkit-scrollbar-track {			border: none;		}		::-webkit-scrollbar-thumb {			background: rgba(100, 100, 100, 0.3); 			border-radius: 5px;		}		::-webkit-scrollbar-track:hover {			background: rgba(0, 0, 0, 0.1); 		}		::-webkit-scrollbar-thumb:hover {			background: rgba(100, 100, 100, 0.7); 		}				/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */		#rendered-md > h1:first-child,		#rendered-md > h2:first-child,		#rendered-md > h3:first-child,		#rendered-md > h4:first-child,		#rendered-md > ul:first-child,		#rendered-md > ol:first-child,		#rendered-md > table:first-child,		#rendered-md > blockquote:first-child,		#rendered-md > img:first-child,		#rendered-md > p:first-child {			margin-top: 0;			padding-top: 0;		}				p, h1, h2, h3, h4, h5, h6, ul, table {			margin-top: .6em;			margin-bottom: 1.35em;			/*				Adds support for RTL text in the note body. It automatically detects the direction using the content.				Issue: https://github.com/laurent22/joplin/issues/3991			*/			unicode-bidi: plaintext;		}		h1, h2, h3, h4, h5, h6, ul, table {			margin-bottom: 0.65em;		}		h1, h2, h3, h4, h5, h6 {			line-height: 1.5em;		}		h1 {			font-size: 1.5em;			font-weight: bold;			border-bottom: 1px solid #dddddd;			padding-bottom: .3em;		}		h2 {			font-size: 1.3em;			font-weight: bold;			padding-bottom: .1em; */		}		h3 {			font-size: 1.1em;			font-weight: bold;		}		h4, h5, h6 {			font-size: 1em;			font-weight: bold;		}		.exported-note-title {			font-size: 2em;			font-weight: bold;			margin-bottom: 0.8em;			line-height: 1.5em;			padding-bottom: .35em;			border-bottom: 1px solid #dddddd;		}		a {			color: #155BDA;		}		ul, ol {			padding-left: 0;			margin-left: 1.7em;		}		li {			margin-bottom: .4em;		}		li p {			margin-top: 0.2em;			margin-bottom: 0;		}		.resource-icon {			display: inline-block;			position: relative;			top: 0.3em;			text-decoration: none;			width: 1.2em;			height: 1.4em;			margin-right: 0.4em;			background-color:  #155BDA;		}    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs      * into the css classes below.     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,     * and of course finishes with ");     * to precvent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;     * on the following line     * */		.fa-joplin {			/* Awesome Font file */			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");		}		.fa-file-image {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-pdf {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-word {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-powerpoint {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-excel {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-audio {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-video {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-archive {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-code {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file-alt, .fa-file-csv {      /* fork-awesome doesn't have csv so we use the text icon */			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		.fa-file {			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");      -webkit-mask-repeat: no-repeat;		}		blockquote {			border-left: 4px solid rgb(220, 220, 220);			padding-left: 1.2em;			margin-left: 0;			opacity: 0.7;		}		.jop-tinymce table,		table {			text-align: left;			border-collapse: collapse;			border: 1px solid rgb(220, 220, 220);			background-color: #ffffff;		}		.jop-tinymce table td, .jop-tinymce table th,		table td, th {			text-align: left;			padding: .5em 1em .5em 1em;			font-size: 15;			color: #32373F;			font-family: 'Avenir', 'Arial', sans-serif;		}		.jop-tinymce table td,		table td {			border: 1px solid rgb(220, 220, 220);		}		.jop-tinymce table th,		table th {			border: 1px solid rgb(220, 220, 220);			border-bottom: 2px solid rgb(220, 220, 220);			background-color: rgb(247, 247, 247);		}		.jop-tinymce table tr:nth-child(even),		table tr:nth-child(even) {			background-color: rgb(247, 247, 247);		}		.jop-tinymce table tr:hover,		table tr:hover {			background-color: #e5e5e5;		}		hr {			border: none;			border-bottom: 2px solid #dddddd;		}		img {			max-width: 100%;			height: auto;		}				.inline-code,		.mce-content-body code {			border: 1px solid rgb(220, 220, 220);			background-color: rgb(243, 243, 243);			padding-right: .2em;			padding-left: .2em;			border-radius: .25em;			color: rgb(0,0,0);			font-size: .9em;		}		.highlighted-keyword {			background-color: #F3B717;			color: black;		}		.not-loaded-resource img {			width: 1.15em;			height: 1.15em;			background: white;			padding: 2px !important;			border-radius: 2px;			box-shadow: 0 1px 3px #000000aa;		}		a.not-loaded-resource img {			margin-right: .2em;		}		a.not-loaded-resource {			display: flex;			flex-direction: row;			align-items: center;		}		.md-checkbox input[type=checkbox]:checked {			opacity: 0.7;		}		.jop-tinymce ul.joplin-checklist .checked,		.md-checkbox .checkbox-label-checked {			opacity: 0.5;		}		.exported-note {			padding: 1em;		}		.joplin-editable .joplin-source {			display: none;		}		mark {			background: #F7D26E;			color: black;		}		/* =============================================== */		/* For TinyMCE */		/* =============================================== */		.mce-content-body {			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */			padding: 5px 10px 10em 0;		}		/*		.mce-content-body code {			background-color: transparent;		}		*/		.mce-content-body [data-mce-selected=inline-boundary] {			background-color: transparent;		}		.mce-content-body .joplin-editable {			cursor: pointer !important;		}		.mce-content-body.mce-content-readonly {			opacity: 0.5;		}		/* We need that to make sure click events have the A has a target */		.katex a span {			pointer-events: none;		}		.media-player {			width: 100%;			margin-top: 10px;		}		.media-player.media-pdf {			min-height: 35rem;			width: 100%;			max-width: 1000px;			margin: 0;			border: 0;			display: block;		}		/* Clear the CODE style if the element is within a joplin-editable block */		.mce-content-body .joplin-editable code {			border: none;			background: none;			padding: 0;			color: inherit;			font-size: inherit;		}		/* To make code blocks horizontally scrollable */		/* https://github.com/laurent22/joplin/issues/5740 */		pre.hljs {			overflow-x: auto;		}		/* =============================================== */		/* For TinyMCE */		/* =============================================== */		@media print {			body {				height: auto !important;			}			pre {				white-space: pre-wrap;			}			.code, .inline-code {				border: 1px solid #CBCBCB;			}			#joplin-container-content {				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go				   around various issues related to scrolling. However when printing we don't want this				   fixed size as that would crop the content. So we set it to auto here. "important" is				   needed to override the style set by JavaScript at the element-level. */				height: auto !important;			}		}					/*					FOR THE MARKDOWN EDITOR				*/				/* Remove the indentation from the checkboxes at the root of the document				   (otherwise they are too far right), but keep it for their children to allow				   nested lists. Make sure this value matches the UL margin. */				li.md-checkbox {					list-style-type: none;				}				li.md-checkbox input[type=checkbox] {					margin-left: -1.71em;					margin-right: 0.7em;				}								ul.joplin-checklist {					list-style:none;				}				/*					FOR THE RICH TEXT EDITOR				*/				ul.joplin-checklist li::before {					content:"\f14a";					font-family:"Font Awesome 5 Free";					background-size: 16px 16px;					pointer-events: all;					cursor: pointer;					width: 1em;					height: 1em;					margin-left: -1.3em;					position: absolute;					color: #32373F;				}				.joplin-checklist li:not(.checked)::before {					content:"\f0c8";				}.mermaid { background-color: white; width: 640px; }/* For styling the rendered Markdown *//* template 1 */.tm-section-half {  padding: 15px;  font-family: "Open Sans", Arial, Helvetica, sans-serif;  font-size: 18px;}.tm-section-half pre {  font-family: "Open Sans", Arial, Helvetica, sans-serif;  font-size: 18px;}.tm-section-title {  font-size: 1.6rem;}.tm-color-primary {  color: #069;}/* template 1 end */</style><div id="rendered-md"><h2 id="내장-함수"><a data-from-md title='https://learn.microsoft.com/ko-kr/sql/t-sql/functions/functions?view=sql-server-2017' href='https://learn.microsoft.com/ko-kr/sql/t-sql/functions/functions?view=sql-server-2017'>내장 함수</a></h2><ul><li><code class="inline-code">MS SQL</code>에서 기본적으로 제공하는 함수<br><br class="jop-noMdConv"/></li></ul><details class="jop-noMdConv"><summary class="jop-noMdConv">전체 리스트</summary><div markdown="1" class="jop-noMdConv"><table><thead><tr><th>이름</th><th>비고</th></tr></thead><tbody><tr><td>트랜잭션 사용</td><td></td></tr><tr><td>임시변수 선언</td><td></td></tr><tr><td>반복문</td><td></td></tr><tr><td>GO</td><td>배치작업 단위</td></tr><tr><td>DISTINCT</td><td>중복 제거</td></tr><tr><td>유니코드</td><td></td></tr><tr><td>NOCOUNT</td><td>결과 행 수 출력</td></tr><tr><td>CURSOR</td><td>1행씩 처리</td></tr><tr><td>ISNULL</td><td>NULL값 처리</td></tr><tr><td>WITH (NOLOCK)</td><td>LOCK 처리</td></tr><tr><td>테이블 변수</td><td></td></tr><tr><td>CONVERT</td><td>타입 변환</td></tr><tr><td>CAST</td><td>타입 변환</td></tr><tr><td>PIVOT</td><td>데이터를 컬럼으로</td></tr><tr><td>UNPIVOT</td><td>컬럼을 데이터로</td></tr><tr><td>LEFT</td><td>문자열 왼쪽부터 가져오기</td></tr><tr><td>RIGHT</td><td>문자열 오른쪽부터 가져오기</td></tr><tr><td>LEN</td><td>문자열 길이</td></tr><tr><td>REPLACE</td><td>단어 바꾸기</td></tr><tr><td>REPLICATE</td><td>자리수 채우기</td></tr><tr><td>SUBSTRING</td><td>문자열 인덱스로 가져오기</td></tr><tr><td>CONCAT</td><td>문자열 합치기</td></tr><tr><td>CHARINDEX</td><td>특정 문자 인덱스 가져오기</td></tr><tr><td>ISNUMERIC</td><td>숫자형인지 확인</td></tr><tr><td>PATINDEX</td><td>패턴 찾기</td></tr><tr><td>STUFF</td><td>문자열 인덱스로 바꾸기</td></tr><tr><td>STRING_AGG</td><td>여러 행 하나로 합치기</td></tr><tr><td>FOR XML PATH</td><td>여러 행 하나로 합치기</td></tr><tr><td>GETDATE</td><td>현재 날짜 가져오기</td></tr><tr><td>DATEADD</td><td>날짜 더하기</td></tr><tr><td>DATEDIFF</td><td>두 개의 날짜 차이값 구하기</td></tr><tr><td>DATEPART</td><td>날짜 형식 가져오기</td></tr><tr><td>EOMONTH</td><td>해당 일의 마지막 날짜 가져오기</td></tr></tbody></table></div></details><br class="jop-noMdConv"/><blockquote><p><a data-from-md title='#%EA%B8%B0%EB%B3%B8-%ED%95%A8%EC%88%98' href='#%EA%B8%B0%EB%B3%B8-%ED%95%A8%EC%88%98'>기본 함수</a><br><a data-from-md title='#%EB%B3%80%ED%99%98-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98' href='#%EB%B3%80%ED%99%98-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98'>변환 관련 함수</a><br><a data-from-md title='#%EB%AC%B8%EC%9E%90-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98' href='#%EB%AC%B8%EC%9E%90-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98'>문자 관련 함수</a><br><a data-from-md title='#%EB%82%A0%EC%A7%9C-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98' href='#%EB%82%A0%EC%A7%9C-%EA%B4%80%EB%A0%A8-%ED%95%A8%EC%88%98'>날짜 관련 함수</a></p></blockquote><br class="jop-noMdConv"/><br class="jop-noMdConv"/><h1 id="기본-함수">기본 함수</h1><h2 id="트랜잭션-사용">트랜잭션 사용</h2><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 기본 사용BEGIN TRAN...COMMIT;-- 이름 지정BEGIN TRAN T1...ROLLBACK TRAN T1;</pre><pre class="hljs"><code><span class="hljs-comment">-- 기본 사용</span><span class="hljs-keyword">BEGIN</span> TRAN...<span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment">-- 이름 지정</span><span class="hljs-keyword">BEGIN</span> TRAN T1...<span class="hljs-keyword">ROLLBACK</span> TRAN T1;</code></pre></div><br class="jop-noMdConv"/><h2 id="임시변수-선언">임시변수 선언</h2><ul><li>변수 사용시 <code class="inline-code">DECLARE</code>, <code class="inline-code">SET</code>, <code class="inline-code">PRINT</code> 와 같이 사용할 수 있다</li><li>@가 붙으면 사용자 변수, @@가 붙은 것은 시스템 변수이다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 임시변수 선언 후 값을 설정DECLARE @TEST INT, @TEST2 INT;SET @TEST = 10;SET @TEST2 = (SELECT 20 AS NUM);</pre><pre class="hljs"><code><span class="hljs-comment">-- 임시변수 선언 후 값을 설정</span><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@TEST</span> <span class="hljs-type">INT</span>, <span class="hljs-variable">@TEST2</span> <span class="hljs-type">INT</span>;<span class="hljs-keyword">SET</span> <span class="hljs-variable">@TEST</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-keyword">SET</span> <span class="hljs-variable">@TEST2</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AS</span> NUM);</code></pre></div><br class="jop-noMdConv"/><h2 id="반복문">반복문</h2><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">DECLARE @TEST INT;SET @TEST = 0;-- WHILE을 사용하여 반복WHILE @TEST &lt; 10BEGIN    SET @TEST = @TEST + 1;END;</pre><pre class="hljs"><code><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@TEST</span> <span class="hljs-type">INT</span>;<span class="hljs-keyword">SET</span> <span class="hljs-variable">@TEST</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">-- WHILE을 사용하여 반복</span>WHILE <span class="hljs-variable">@TEST</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span><span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SET</span> <span class="hljs-variable">@TEST</span> <span class="hljs-operator">=</span> <span class="hljs-variable">@TEST</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">END</span>;</code></pre></div><br class="jop-noMdConv"/><h2 id="go">GO</h2><ul><li>일괄처리 단위</li><li>명령어를 묶음 단위로 처리하기 위해 사용</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">CREATE TABLE ...GOINSERT INTO ...GOUPDATE SET ...GO</pre><pre class="hljs"><code><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ...GO<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> ...GO<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SET</span> ...GO</code></pre></div><br class="jop-noMdConv"/><h2 id="distinct">DISTINCT</h2><ul><li>컬럼의 중복값을 제거한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 중복되는 NAME은 한번만 출력된다SELECT DISTINCT NAME FROM TEST;</pre><pre class="hljs"><code><span class="hljs-comment">-- 중복되는 NAME은 한번만 출력된다</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> NAME <span class="hljs-keyword">FROM</span> TEST;</code></pre></div><br class="jop-noMdConv"/><h2 id="유니코드">유니코드</h2><ul><li>문자열 앞에 <code class="inline-code">N</code>을 붙여서 유니코드임을 명시</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT N'AAA' AS NAME</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> N<span class="hljs-string">&#x27;AAA&#x27;</span> <span class="hljs-keyword">AS</span> NAME</code></pre></div><br class="jop-noMdConv"/><h2 id="nocount">NOCOUNT</h2><ul><li>쿼리문의 영향을 받은 데이터의 숫자를 결과 집합의 일부로 반환하지 않도록 한다</li><li>처리량이 줄어들어 성능이 향상된다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 행수 표시 안함SET NOCOUNT ON;</pre><pre class="hljs"><code><span class="hljs-comment">-- 행수 표시 안함</span><span class="hljs-keyword">SET</span> NOCOUNT <span class="hljs-keyword">ON</span>;</code></pre></div><br class="jop-noMdConv"/><h2 id="cursor">CURSOR</h2><ul><li><code class="inline-code">SELECT</code>로 가져온 결과를 하나씩 읽어들여 처리하고 싶을때 사용</li><li>많은 데이터를 처리해야 할 경우 성능이 좋지 않기 때문에 가급적 사용해선 안된다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">DECLARE @EMAIL VARCHAR(100);DECLARE @IDX INT;SET @IDX = 0;-- 커서 정의 (1개씩 가져올 컬럼 정의)DECLARE CursorEmail CURSORFOR (SELECT EMAIL FROM TABLE_E WHERE IS_DEL = 'FALSE');-- 커서 시작OPEN CursorEmail;-- 컬럼에서 데이터 1행씩 가져오기FETCH NEXT FROM CursorEmail Into @EMAIL;WHILE (@@FETCH_STATUS &lt;&gt; -1)BEGIN    SET @IDX = @IDX + 1;        UPDATE TABLE_E SET GROUP_IDX = @IDX WHERE EMAIL = @EMAIL;        FETCH NEXT FROM CursorEmail INTO @EMAIL;END;-- 커서 종료CLOSE CursorEmail;-- 자원 회수DEALLOCATE CursorEmail;</pre><pre class="hljs"><code><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@EMAIL</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>);<span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@IDX</span> <span class="hljs-type">INT</span>;<span class="hljs-keyword">SET</span> <span class="hljs-variable">@IDX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">-- 커서 정의 (1개씩 가져올 컬럼 정의)</span><span class="hljs-keyword">DECLARE</span> CursorEmail <span class="hljs-keyword">CURSOR</span><span class="hljs-keyword">FOR</span> (<span class="hljs-keyword">SELECT</span> EMAIL <span class="hljs-keyword">FROM</span> TABLE_E <span class="hljs-keyword">WHERE</span> IS_DEL <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;FALSE&#x27;</span>);<span class="hljs-comment">-- 커서 시작</span><span class="hljs-keyword">OPEN</span> CursorEmail;<span class="hljs-comment">-- 컬럼에서 데이터 1행씩 가져오기</span><span class="hljs-keyword">FETCH</span> NEXT <span class="hljs-keyword">FROM</span> CursorEmail <span class="hljs-keyword">Into</span> <span class="hljs-variable">@EMAIL</span>;WHILE (@<span class="hljs-variable">@FETCH</span>_STATUS <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">-1</span>)<span class="hljs-keyword">BEGIN</span>    <span class="hljs-keyword">SET</span> <span class="hljs-variable">@IDX</span> <span class="hljs-operator">=</span> <span class="hljs-variable">@IDX</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">UPDATE</span> TABLE_E <span class="hljs-keyword">SET</span> GROUP_IDX <span class="hljs-operator">=</span> <span class="hljs-variable">@IDX</span> <span class="hljs-keyword">WHERE</span> EMAIL <span class="hljs-operator">=</span> <span class="hljs-variable">@EMAIL</span>;        <span class="hljs-keyword">FETCH</span> NEXT <span class="hljs-keyword">FROM</span> CursorEmail <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@EMAIL</span>;<span class="hljs-keyword">END</span>;<span class="hljs-comment">-- 커서 종료</span><span class="hljs-keyword">CLOSE</span> CursorEmail;<span class="hljs-comment">-- 자원 회수</span><span class="hljs-keyword">DEALLOCATE</span> CursorEmail;</code></pre></div><br class="jop-noMdConv"/><h2 id="isnull-column-default">ISNULL (column, default)</h2><ul><li>값이 <code class="inline-code">NULL</code>인 경우 디폴트 값을 출력한다</li><li><code class="inline-code">NULL</code>이 포함된 계산은 <code class="inline-code">NULL</code>값이 나오기 때문에 이를 방지하기 위해 사용</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT ISNULL(NAME, 'ABC') AS NAMEFROM TEST;</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> ISNULL(NAME, <span class="hljs-string">&#x27;ABC&#x27;</span>) <span class="hljs-keyword">AS</span> NAME<span class="hljs-keyword">FROM</span> TEST;</code></pre></div><br class="jop-noMdConv"/><h2 id="with-nolock">WITH (NOLOCK)</h2><ul><li>조회 중인 데이터를 수정할 수 있도록 설정한다</li><li><code class="inline-code">SQL SERVER</code>의 기본적인 격리 수준은 <code class="inline-code">READ COMMIT</code>이기 때문에 사용<br>→  <code class="inline-code">SELECT</code> 중인 데이터나 테이블은 수정 불가능하기 때문에 성능 개선을 위해 사용</li><li>데이터 정합성이 떨어지는 단점이 있다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT *FROM TEST WITH (NOLOCK);</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> TEST <span class="hljs-keyword">WITH</span> (NOLOCK);</code></pre></div><br class="jop-noMdConv"/><h2 id="테이블-변수">테이블 변수</h2><ul><li>쿼리에서 테이블을 생성 할때 @를 붙여서 테이블 변수로 생성 가능</li><li>임시 테이블과 사용법은 같으나 소용량 데이터 처리에 유리하다 (100건 이하)</li><li>명시적으로 삭제하지 않을 경우 배치 처리기간 동안 존재한다<br>→ 배치 처리단위인 프로시저에서 사용 시 유리</li><li>프로시저에서 사용하면 임시 테이블을 사용 할 때보다 컴파일을 적게 해서 성능상 유리하다</li><li>임시 테이블과 마찬가지로 Tempdb에 저장된다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">DECLARE @TEST TABLE (    ID INT NOT NULL,    NAME VARCHAR(20));INSERT INTO @TESTSELECT ID, NAMEFROM TEST;SELECT * FROM @TEST;</pre><pre class="hljs"><code><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@TEST</span> <span class="hljs-keyword">TABLE</span> (    ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,    NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@TEST</span><span class="hljs-keyword">SELECT</span> ID, NAME<span class="hljs-keyword">FROM</span> TEST;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-variable">@TEST</span>;</code></pre></div><br class="jop-noMdConv"/><br class="jop-noMdConv"/><h1 id="변환-관련-함수">변환 관련 함수</h1><h2 id="convert-type-target-style-number"><a data-from-md title='https://learn.microsoft.com/ko-kr/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-2017' href='https://learn.microsoft.com/ko-kr/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-2017'>CONVERT (type, target, style number)</a></h2><ul><li>대상을 설정한 타입의 형태로 변환</li><li>타입의 길이를 조절하여 앞에서 부터 원하는 길이 만큼만 가져올 수 있다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT CONVERT(VARCHAR(7), '2023-01-01 12:00:00', 120)-- 2023-01 출력</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONVERT</span>(<span class="hljs-type">VARCHAR</span>(<span class="hljs-number">7</span>), <span class="hljs-string">&#x27;2023-01-01 12:00:00&#x27;</span>, <span class="hljs-number">120</span>)<span class="hljs-comment">-- 2023-01 출력</span></code></pre></div><br class="jop-noMdConv"/><h2 id="cast-target-as-type">CAST (target AS type)</h2><ul><li>대상을 설정한 타입의 형태로 변환</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT CAST(100 AS NUMERIC(13,3));-- 100.000 출력</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>(<span class="hljs-number">100</span> <span class="hljs-keyword">AS</span> <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">13</span>,<span class="hljs-number">3</span>));<span class="hljs-comment">-- 100.000 출력</span></code></pre></div><br class="jop-noMdConv"/><h2 id="pivot-column-for-target-in-value">PIVOT ( column FOR (target) IN (value) )</h2><ul><li>테이블의 데이터중 특정 데이터를 컬럼으로 사용하여 요약된 결과를 만든다</li><li>데이터 값을 컬럼으로 만들고 싶을때 사용한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT INFO, LANG, MATHFROM TESTPIVOT (    MAX(SCORE) FOR SUBJECT IN (LANG, MATH)) AS PVT</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> INFO, LANG, MATH<span class="hljs-keyword">FROM</span> TESTPIVOT (    <span class="hljs-built_in">MAX</span>(SCORE) <span class="hljs-keyword">FOR</span> SUBJECT <span class="hljs-keyword">IN</span> (LANG, MATH)) <span class="hljs-keyword">AS</span> PVT</code></pre></div><table><thead><tr><th>INFO</th><th>SUBJECT</th><th>SCORE</th></tr></thead><tbody><tr><td>A</td><td>LANG</td><td>90</td></tr><tr><td>A</td><td>MATH</td><td>85</td></tr><tr><td>B</td><td>LANG</td><td>100</td></tr><tr><td>B</td><td>MATH</td><td>90</td></tr></tbody></table><p><font size="10" class="jop-noMdConv">                ↓</font></p><table><thead><tr><th>INFO</th><th>LANG</th><th>MATH</th></tr></thead><tbody><tr><td>A</td><td>90</td><td>85</td></tr><tr><td>B</td><td>100</td><td>90</td></tr></tbody></table><br class="jop-noMdConv"/><h2 id="unpivot-total-column-for-column-in-unpivot-target-column">UNPIVOT ( total column FOR (column) IN (unpivot target column) )</h2><ul><li>테이블의 데이터중 컬럼을 데이터 형태로 변경하여 표시</li><li>컬럼을 데이터 값으로 만들고 싶을때 사용</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT INFO, SUBJECT, SCOREFROM TESTUNPIVOT (    SCORE FOR SUBJECT IN (LANG, MATH, ENG)) AS UNPVT</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> INFO, SUBJECT, SCORE<span class="hljs-keyword">FROM</span> TESTUNPIVOT (    SCORE <span class="hljs-keyword">FOR</span> SUBJECT <span class="hljs-keyword">IN</span> (LANG, MATH, ENG)) <span class="hljs-keyword">AS</span> UNPVT</code></pre></div><table><thead><tr><th>INFO</th><th>LANG</th><th>MATH</th><th>ENG</th></tr></thead><tbody><tr><td>A</td><td>90</td><td>80</td><td>95</td></tr><tr><td>B</td><td>75</td><td>85</td><td>80</td></tr><tr><td>C</td><td>85</td><td>90</td><td>90</td></tr></tbody></table><p><font size="10" class="jop-noMdConv">                ↓</font></p><table><thead><tr><th>INFO</th><th>SUBJECT</th><th>SCORE</th></tr></thead><tbody><tr><td>A</td><td>LANG</td><td>90</td></tr><tr><td>A</td><td>MATH</td><td>80</td></tr><tr><td>A</td><td>ENG</td><td>95</td></tr><tr><td>B</td><td>LANG</td><td>75</td></tr><tr><td>B</td><td>MATH</td><td>85</td></tr><tr><td>B</td><td>ENG</td><td>80</td></tr><tr><td>C</td><td>LANG</td><td>85</td></tr><tr><td>C</td><td>MATH</td><td>90</td></tr><tr><td>C</td><td>ENG</td><td>90</td></tr></tbody></table><br class="jop-noMdConv"/><br class="jop-noMdConv"/><h1 id="문자-관련-함수">문자 관련 함수</h1><h2 id="left-text-size">LEFT (text, size)</h2><ul><li>문자열의 왼쪽부터 지정한 수 만큼의 문자를 반환한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT LEFT('ABCD', 2)-- AB 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">-- AB 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="right-text-size">RIGHT (text, size)</h2><ul><li>문자열의 오른쪽부터 지정된 숫자만큼의 문자를 반환한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT RIGHT('ABCD', 2);-- CD 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">RIGHT</span>(<span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">-- CD 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="len-text">LEN (text)</h2><ul><li>문자열의 길이를 반환</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT LEN('ABC');-- 3 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> LEN(<span class="hljs-string">&#x27;ABC&#x27;</span>);<span class="hljs-comment">-- 3 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="replace-text-before-after">REPLACE (text, before, after)</h2><ul><li>문자열에서 바꾸고 싶은 문자를 다른 문자로 변환</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT REPLACE('AAAAA', 'A', 'B');-- BBBBB 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> REPLACE(<span class="hljs-string">&#x27;AAAAA&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<span class="hljs-comment">-- BBBBB 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="replicate-text-size">REPLICATE (text, size)</h2><ul><li>대상에 특정 문자를 설정한 크기만큼 붙여준다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT REPLICATE('0', 7 - LEN('1369')) + '1369';-- 0001369 반환-- 숫자인 경우SELECT REPLICATE(0, 7 - LEN(1369)) + CONVERT(VARCHAR, 1369);</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> REPLICATE(<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">7</span> <span class="hljs-operator">-</span> LEN(<span class="hljs-string">&#x27;1369&#x27;</span>)) <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;1369&#x27;</span>;<span class="hljs-comment">-- 0001369 반환</span><span class="hljs-comment">-- 숫자인 경우</span><span class="hljs-keyword">SELECT</span> REPLICATE(<span class="hljs-number">0</span>, <span class="hljs-number">7</span> <span class="hljs-operator">-</span> LEN(<span class="hljs-number">1369</span>)) <span class="hljs-operator">+</span> <span class="hljs-keyword">CONVERT</span>(<span class="hljs-type">VARCHAR</span>, <span class="hljs-number">1369</span>);</code></pre></div><br class="jop-noMdConv"/><h2 id="substring-text-start-index-size">SUBSTRING (text, start index, size)</h2><ul><li>문자열의 시작 인덱스부터 크기 만큼의 문자를 가져온다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT SUBSTRING('ABCDEFG', 1, 3);-- ABC 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">-- ABC 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="concat-text-text">CONCAT (text, text)</h2><ul><li>문자열을 합칠때 사용한다</li><li>대부분의 벤더에서 공통으로 사용한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT CONCAT('ABC', '123');-- ABC123 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>);<span class="hljs-comment">-- ABC123 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="charindex-target-text-start-index">CHARINDEX (target, text, start index)</h2><ul><li>문자열에서 문자를 찾아 인덱스를 반환</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT CHARINDEX('다', '가나다라마', 2)-- 3 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> CHARINDEX(<span class="hljs-string">&#x27;다&#x27;</span>, <span class="hljs-string">&#x27;가나다라마&#x27;</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">-- 3 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="isnumeric-text">ISNUMERIC (text)</h2><ul><li>해당 문자열이 숫자형이면 1을 반환하고 아니면 0을 반환한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT ISNUMERIC('9999');-- 1 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> ISNUMERIC(<span class="hljs-string">&#x27;9999&#x27;</span>);<span class="hljs-comment">-- 1 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="patindex-pattern-text">PATINDEX (pattern, text)</h2><ul><li>패턴이 처음 나타나는 시작 위치를 반환하거나 0을 반환 한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT PATINDEX('%CcC%', 'AaBbCCCDEFG');-- 5 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> PATINDEX(<span class="hljs-string">&#x27;%CcC%&#x27;</span>, <span class="hljs-string">&#x27;AaBbCCCDEFG&#x27;</span>);<span class="hljs-comment">-- 5 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="stuff-text-start-index-size-replace-char">STUFF (text, start index, size, replace char)</h2><ul><li>문자열을 자리수만큼 특정 문자로 치환한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT STUFF('ABCDE', 1, 2, 'TAB_');-- TAB_CDE 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> STUFF(<span class="hljs-string">&#x27;ABCDE&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;TAB_&#x27;</span>);<span class="hljs-comment">-- TAB_CDE 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="string_agg-column-separator-group-by">STRING_AGG (column, separator) ... GROUP BY</h2><ul><li>그룹화된 테이블에서 여러 행의 문자열을 하나로 합칠때 사용한다</li><li>SQL Server 2017 이후 부터 지원</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT  JOB        , STRING_AGG(NAME, ',') AS NAMEFROM TESTGROUP BY JOB;</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span>  JOB        , STRING_AGG(NAME, <span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-keyword">AS</span> NAME<span class="hljs-keyword">FROM</span> TEST<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> JOB;</code></pre></div><table><thead><tr><th>JOB</th><th>NAME</th></tr></thead><tbody><tr><td>MANAGER</td><td>BLAKE,CLARK,JONES</td></tr><tr><td>SALESMAN</td><td>ALLEN,WARD,MARTIN,TURNER</td></tr></tbody></table><br class="jop-noMdConv"/><h2 id="for-xml-path-tag">FOR XML PATH (tag)</h2><ul><li>데이터를 <code class="inline-code">XML PATH</code> 형태로 반환한다</li><li>여러 행의 문자열을 하나로 합칠때 사용한다</li><li>문자열을 자리수만큼 특정 문자로 치환하는 <code class="inline-code">STUFF</code>와 자주 같이 사용된다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 컬럼명이 있을 경우SELECT NAMEFROM TESTFOR XML PATH('TAB');</pre><pre class="hljs"><code><span class="hljs-comment">-- 컬럼명이 있을 경우</span><span class="hljs-keyword">SELECT</span> NAME<span class="hljs-keyword">FROM</span> TEST<span class="hljs-keyword">FOR</span> XML PATH(<span class="hljs-string">&#x27;TAB&#x27;</span>);</code></pre></div><table><thead><tr><th>XML_.....</th></tr></thead><tbody><tr><td>&lt;TAB&gt;&lt;NAME&gt;ABC&lt;/NAME&gt;&lt;/TAB&gt;.....</td></tr></tbody></table><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 컬럼명이 없을 경우SELECT ',' + NAMEFROM TESTFOR XML PATH('');</pre><pre class="hljs"><code><span class="hljs-comment">-- 컬럼명이 없을 경우</span><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-operator">+</span> NAME<span class="hljs-keyword">FROM</span> TEST<span class="hljs-keyword">FOR</span> XML PATH(<span class="hljs-string">&#x27;&#x27;</span>);</code></pre></div><table><thead><tr><th>XML_.....</th></tr></thead><tbody><tr><td>,ABC,XYZ.....</td></tr></tbody></table><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- STUFF와 같이 사용SELECT  A.JOB        , STUFF( (SELECT ',' + NAME FROM TEST_ANOTHER WHERE JOB = A.JOB FOR XML PATH('')), 1, 1, '' ) AS NAMEFROM TEST AS AGROUP BY A.JOB;</pre><pre class="hljs"><code><span class="hljs-comment">-- STUFF와 같이 사용</span><span class="hljs-keyword">SELECT</span>  A.JOB        , STUFF( (<span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-operator">+</span> NAME <span class="hljs-keyword">FROM</span> TEST_ANOTHER <span class="hljs-keyword">WHERE</span> JOB <span class="hljs-operator">=</span> A.JOB <span class="hljs-keyword">FOR</span> XML PATH(<span class="hljs-string">&#x27;&#x27;</span>)), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&#x27;</span> ) <span class="hljs-keyword">AS</span> NAME<span class="hljs-keyword">FROM</span> TEST <span class="hljs-keyword">AS</span> A<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> A.JOB;</code></pre></div><table><thead><tr><th>JOB</th><th>NAME</th></tr></thead><tbody><tr><td>MANAGER</td><td>BLAKE,CLARK,JONES</td></tr><tr><td>SALESMAN</td><td>ALLEN,WARD,MARTIN,TURNER</td></tr></tbody></table><br class="jop-noMdConv"/><br class="jop-noMdConv"/><h1 id="날짜-관련-함수">날짜 관련 함수</h1><h2 id="getdate">GETDATE ()</h2><ul><li>현재 컴퓨터에 설정되어 있는 시스템 시간을 불러온다</li><li><code class="inline-code">yyyy-mm-dd hh:mm:ss</code></li></ul><br class="jop-noMdConv"/><h2 id="dateadd-type-num-date">DATEADD (type, num, date)</h2><ul><li>날짜의 타입에 숫자만큼 더한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 2개월 후SELECT DATEADD(MONTH, 2, GETDATE());-- 30일 전SELECT DATEADD(DAY, -30, GETDATE());</pre><pre class="hljs"><code><span class="hljs-comment">-- 2개월 후</span><span class="hljs-keyword">SELECT</span> DATEADD(<span class="hljs-keyword">MONTH</span>, <span class="hljs-number">2</span>, GETDATE());<span class="hljs-comment">-- 30일 전</span><span class="hljs-keyword">SELECT</span> DATEADD(<span class="hljs-keyword">DAY</span>, <span class="hljs-number">-30</span>, GETDATE());</code></pre></div><br class="jop-noMdConv"/><h2 id="datediff-type-target-a-target-b">DATEDIFF (type, target A, target B)</h2><ul><li>날짜 형식으로 <code class="inline-code">B - A</code>의 값을 구한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT DATEDIFF(DAY, '20210101', '20210105');-- 4 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> DATEDIFF(<span class="hljs-keyword">DAY</span>, <span class="hljs-string">&#x27;20210101&#x27;</span>, <span class="hljs-string">&#x27;20210105&#x27;</span>);<span class="hljs-comment">-- 4 반환</span></code></pre></div><br class="jop-noMdConv"/><h2 id="datepart-type-date">DATEPART (type, date)</h2><ul><li>날짜의 데이터를 선택한 타입으로 반환한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">-- 2021-01-01이 무슨 요일인지 반환-- 일요일=1, 월요일=2, ... 토요일=7SELECT DATEPART(DW, '20210101');-- 2023-01-01 ~ 2023-01-31 사이에 토요일이 몇 번 있는지 반환SELECT ((DATEDIFF(DAY, '2023-01-01', '2023-01-31')+1) / 7) +              CASE WHEN (7 - DATEPART(DW, '2023-01-01'))                  BETWEEN 0 AND ((DATEDIFF(DAY, '2023-01-01', '2023-01-31')+1) % 7 - 1) THEN 1 ELSE 0              END;-- 시간만 반환 (21)SELECT DATEPART(HOUR, '2021-01-01 21:23');</pre><pre class="hljs"><code><span class="hljs-comment">-- 2021-01-01이 무슨 요일인지 반환</span><span class="hljs-comment">-- 일요일=1, 월요일=2, ... 토요일=7</span><span class="hljs-keyword">SELECT</span> DATEPART(DW, <span class="hljs-string">&#x27;20210101&#x27;</span>);<span class="hljs-comment">-- 2023-01-01 ~ 2023-01-31 사이에 토요일이 몇 번 있는지 반환</span><span class="hljs-keyword">SELECT</span> ((DATEDIFF(<span class="hljs-keyword">DAY</span>, <span class="hljs-string">&#x27;2023-01-01&#x27;</span>, <span class="hljs-string">&#x27;2023-01-31&#x27;</span>)<span class="hljs-operator">+</span><span class="hljs-number">1</span>) <span class="hljs-operator">/</span> <span class="hljs-number">7</span>) <span class="hljs-operator">+</span>              <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (<span class="hljs-number">7</span> <span class="hljs-operator">-</span> DATEPART(DW, <span class="hljs-string">&#x27;2023-01-01&#x27;</span>))                  <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> ((DATEDIFF(<span class="hljs-keyword">DAY</span>, <span class="hljs-string">&#x27;2023-01-01&#x27;</span>, <span class="hljs-string">&#x27;2023-01-31&#x27;</span>)<span class="hljs-operator">+</span><span class="hljs-number">1</span>) <span class="hljs-operator">%</span> <span class="hljs-number">7</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>              <span class="hljs-keyword">END</span>;<span class="hljs-comment">-- 시간만 반환 (21)</span><span class="hljs-keyword">SELECT</span> DATEPART(<span class="hljs-keyword">HOUR</span>, <span class="hljs-string">&#x27;2021-01-01 21:23&#x27;</span>);</code></pre></div><br class="jop-noMdConv"/><h2 id="eomonth-date">EOMONTH (date)</h2><ul><li>날짜가 포함된 월의 마지막 날짜를 반환</li><li>SQL SERVER 2012 이상 에서만 동작한다</li></ul><div class="joplin-editable"><pre class="joplin-source" data-joplin-language="sql" data-joplin-source-open="```sql&#10;" data-joplin-source-close="&#10;```">SELECT EOMONTH('20210520');-- 2021-05-31 반환</pre><pre class="hljs"><code><span class="hljs-keyword">SELECT</span> EOMONTH(<span class="hljs-string">&#x27;20210520&#x27;</span>);<span class="hljs-comment">-- 2021-05-31 반환</span></code></pre></div><br class="jop-noMdConv"/></div></div>					</body>				</html>			