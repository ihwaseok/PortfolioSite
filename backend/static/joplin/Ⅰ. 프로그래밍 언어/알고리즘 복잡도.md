<!-- --- --><!-- title: 알고리즘 복잡도 --><!-- updated: 2022-12-19 07:40:16Z --><!-- created: 2022-12-19 06:57:31Z --><!-- latitude: 37.24108640 --><!-- longitude: 127.17755370 --><!-- altitude: 0.0000 --><!-- --- -->## 시간 복잡도- 알고리즘의 수행 시간을 평가 → 기본연산의 실행 횟수로 평가- 일반적으로 빅오 표기법으로 표현<br>## 공간 복잡도- 알고리즘에서 사용하는 메모리의 양을 평가- 일반적으로 빅오 표기법으로 표현<br>## O(n) : 빅오 표기법- 최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림- T(n) = n<sup>2</sup> + 2n + 1 ▶ O(n<sup>2</sup>)  → 가장 큰 입력크기 n<sup>2</sup>만 표기 (최고 차항만 표현)- T(n) = 2n ▶ O(n) → 큰 차이가 없기 때문에 최고 차항의 계수는 제외<br>## O(1) : 상수 시간- 입력크기에 상관없이 일정한 연산 수행```java// n=10 일때, 1번 실행됨void test(int n) {	System.out.println();}```<br>## O(log N) : 로그 시간- 입력크기가 커질때 연산 횟수가 logN에 비례해서 증가- 이진 탐색의 경우```java// n=10 일때, 5번 실행됨for (int i=1; i <= n; i*2) {	System.out.println();}```<br>## O(n) : 선형 시간- 입력크기가 커질때 연산 횟수가 n에 비례해서 증가```java// n=10 일때, 10번 실행됨for (int i=1; i <= n; i++) {	System.out.println();}```<br>## O(n<sup>2</sup>) : 2차 시간- 입력크기가 커질때 연산 횟수가 n<sup>2</sup>에 비례해서 증가- 이중 반복문의 경우```java// n=10 일때, 100번 실행됨for (int i=1; i <= n; i++) {	for (int j=1; j <= n; j++) {		System.out.println();		}}```<br>## O(2<sup>n</sup>) : 지수 시간- 입력크기가 커질때 연산 횟수가 2<sup>n</sup>에 비례해서 증가- 재귀 함수에서 반환을 2개씩 할 경우 ```java// 피보나치의 수 로직 : 1, 1, 2, 3, 5, 8// n=10 일때, 1024번 실행됨 : n → (n-1, n-2) → ((n-2, n-3), (n-3, n-4)) → ...int test(int n) {		if (n <= 1) {		return n;	}		return test(n-1) + test(n-2);}```<br>![02a0741486b16101f6bb72f007f63361.png](/joplinRes/_resources/02a0741486b16101f6bb72f007f63361.png)